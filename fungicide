#!/bin/bash
# fungicide - IRC/Slack style output for NATS JetStream
# https://github.com/k4therin2/fungicide
#
# Usage: fungicide [options] [subject_pattern]
#
# Options:
#   -n, --history COUNT   Show last COUNT messages before live tail (default: 50)
#   -s, --streams LIST    Comma-separated stream names to read history from
#   -a, --all             Show all lines (don't collapse long messages)
#   -m, --military        Use 24-hour military time (default: 12-hour AM/PM)
#   -z, --timezone TZ     Timezone for display (default: local, e.g., America/New_York)
#   -h, --help            Show this help message
#
# Examples:
#   fungicide                           # Subscribe to all subjects, 50 msg history
#   fungicide -n 20                     # Last 20 messages then live tail
#   fungicide -a                        # Show full messages (no collapsing)
#   fungicide "agent-chat.>"            # Custom subject pattern
#   fungicide -s "STREAM1,STREAM2" -n 10  # Specific streams

set -e

# Colors
RESET='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'
CYAN='\033[36m'
GREEN='\033[32m'
YELLOW='\033[33m'
MAGENTA='\033[35m'
BLUE='\033[34m'
WHITE='\033[37m'
GRAY='\033[90m'

# Channel colors (rotate through these)
CHANNEL_COLORS=("$CYAN" "$GREEN" "$YELLOW" "$MAGENTA" "$BLUE")

# Defaults
HISTORY_COUNT=50
SUBJECT_PATTERN=""
STREAMS=""
SHOW_ALL=false
MAX_LINES=5
MILITARY_TIME=false
TIMEZONE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -n|--history)
      HISTORY_COUNT="$2"
      shift 2
      ;;
    -s|--streams)
      STREAMS="$2"
      shift 2
      ;;
    -a|--all)
      SHOW_ALL=true
      shift
      ;;
    -m|--military)
      MILITARY_TIME=true
      shift
      ;;
    -z|--timezone)
      TIMEZONE="$2"
      shift 2
      ;;
    -h|--help)
      head -24 "$0" | tail -22 | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
    *)
      SUBJECT_PATTERN="$1"
      shift
      ;;
  esac
done

# Check dependencies
if ! command -v nats &> /dev/null; then
  echo -e "${BOLD}Error:${RESET} nats CLI not found. Install with: ${CYAN}brew install nats-io/nats-tools/nats${RESET}"
  exit 1
fi

if ! command -v jq &> /dev/null; then
  echo -e "${BOLD}Error:${RESET} jq not found. Install with: ${CYAN}brew install jq${RESET}"
  exit 1
fi

# Auto-detect streams if not specified
if [[ -z "$STREAMS" ]]; then
  STREAMS=$(nats stream ls -n 2>/dev/null | tr '\n' ',' | sed 's/,$//')
fi

# Auto-detect subject pattern from first stream if not specified
if [[ -z "$SUBJECT_PATTERN" ]]; then
  first_stream=$(echo "$STREAMS" | cut -d',' -f1)
  if [[ -n "$first_stream" ]]; then
    # Try to get subjects from stream config
    subjects=$(nats stream info "$first_stream" -j 2>/dev/null | jq -r '.config.subjects[]? // empty' | head -1)
    if [[ -n "$subjects" ]]; then
      # Convert specific subject to wildcard (e.g., agent-chat.coordination -> agent-chat.>)
      SUBJECT_PATTERN=$(echo "$subjects" | sed 's/\.[^.]*$/.\>/')
    fi
  fi
  # Fallback to ">" (all subjects)
  if [[ -z "$SUBJECT_PATTERN" ]]; then
    SUBJECT_PATTERN=">"
  fi
fi

# Get color for channel (consistent per channel name)
get_channel_color() {
  local channel="$1"
  local hash=0
  for (( i=0; i<${#channel}; i++ )); do
    hash=$((hash + $(printf '%d' "'${channel:$i:1}")))
  done
  local idx=$((hash % ${#CHANNEL_COLORS[@]}))
  echo "${CHANNEL_COLORS[$idx]}"
}

# Format timestamp for display
format_timestamp() {
  local iso_ts="$1"
  local formatted_ts=""

  if [[ "$MILITARY_TIME" == "true" ]]; then
    local time_fmt="%Y-%m-%d %H:%M:%S"
  else
    local time_fmt="%Y-%m-%d %I:%M:%S %p"
  fi

  if [[ -n "$TIMEZONE" ]]; then
    formatted_ts=$(TZ="$TIMEZONE" date -j -f "%Y-%m-%dT%H:%M:%S" "${iso_ts%%.*}" +"$time_fmt" 2>/dev/null || echo "$iso_ts")
  else
    if date --version &>/dev/null; then
      formatted_ts=$(date -d "$iso_ts" +"$time_fmt" 2>/dev/null || echo "$iso_ts")
    else
      local date_part=$(echo "$iso_ts" | cut -d'T' -f1)
      local time_part=$(echo "$iso_ts" | cut -d'T' -f2 | cut -d'.' -f1 | cut -d'Z' -f1 | cut -d'+' -f1)
      formatted_ts=$(TZ=UTC date -j -f "%Y-%m-%d %H:%M:%S" "$date_part $time_part" +"$time_fmt" 2>/dev/null)
      if [[ -z "$formatted_ts" ]]; then
        formatted_ts="${date_part} ${time_part}"
      fi
    fi
  fi
  echo "$formatted_ts"
}

# Format and display a message
format_message() {
  local subject="$1"
  local json="$2"

  # Extract channel from subject (last part after last dot)
  local channel=$(echo "$subject" | rev | cut -d'.' -f1 | rev)

  local handle=$(echo "$json" | jq -r '.handle // .user // .from // "unknown"' 2>/dev/null)
  local message=$(echo "$json" | jq -r '.message // .text // .content // .data // .' 2>/dev/null)
  local timestamp=$(echo "$json" | jq -r '.timestamp // .time // .ts // ""' 2>/dev/null)

  # Format timestamp
  if [[ -n "$timestamp" ]]; then
    timestamp=$(format_timestamp "$timestamp")
  fi

  local channel_color=$(get_channel_color "$channel")

  if [[ -n "$message" && "$message" != "null" ]]; then
    # Count lines in message
    local line_count=$(printf '%s' "$message" | wc -l | tr -d ' ')
    line_count=$((line_count + 1))  # wc -l counts newlines, not lines

    if [[ "$line_count" -eq 1 ]]; then
      # Single line - print normally
      echo -e "${DIM}${timestamp}${RESET} ${channel_color}#${channel}${RESET} ${BOLD}${WHITE}${handle}${RESET}${DIM}:${RESET} ${message}"
    elif [[ "$SHOW_ALL" == "true" ]]; then
      # Show all lines with indentation
      echo -e "${DIM}${timestamp}${RESET} ${channel_color}#${channel}${RESET} ${BOLD}${WHITE}${handle}${RESET}${DIM}:${RESET}"
      printf '%s\n' "$message" | while IFS= read -r line; do
        echo -e "    ${line}"
      done
    elif [[ "$line_count" -le "$MAX_LINES" ]]; then
      # 2-5 lines - show all with indentation
      echo -e "${DIM}${timestamp}${RESET} ${channel_color}#${channel}${RESET} ${BOLD}${WHITE}${handle}${RESET}${DIM}:${RESET}"
      printf '%s\n' "$message" | while IFS= read -r line; do
        echo -e "    ${line}"
      done
    else
      # More than 5 lines - show first line, hidden count on line 2, last 3 lines
      local first_line=$(printf '%s' "$message" | head -1)
      local hidden=$((line_count - 4))

      echo -e "${DIM}${timestamp}${RESET} ${channel_color}#${channel}${RESET} ${BOLD}${WHITE}${handle}${RESET}${DIM}:${RESET} ${first_line}"
      echo -e "    ${GRAY}... ${hidden} lines hidden (use -a to expand)${RESET}"
      printf '%s\n' "$message" | tail -3 | while IFS= read -r line; do
        echo -e "    ${line}"
      done
    fi
  fi
}

# Temp file for collecting history messages
HISTORY_JSON_TMP=$(mktemp)
trap "rm -f $HISTORY_JSON_TMP" EXIT

# Fetch history from streams
if [[ "$HISTORY_COUNT" -gt 0 && -n "$STREAMS" ]]; then
  echo -e "${BOLD}${MAGENTA}=== Last $HISTORY_COUNT messages ===${RESET}"

  # Initialize JSON array
  echo '[]' > "$HISTORY_JSON_TMP"

  IFS=',' read -ra STREAM_ARRAY <<< "$STREAMS"
  for stream in "${STREAM_ARRAY[@]}"; do
    stream=$(echo "$stream" | xargs)  # trim whitespace
    [[ -z "$stream" ]] && continue

    # Get stream info to find last sequence
    stream_info=$(nats stream info "$stream" -j 2>/dev/null || echo '{}')
    last_seq=$(echo "$stream_info" | jq -r '.state.last_seq // 0')

    [[ "$last_seq" == "0" || "$last_seq" == "null" ]] && continue

    first_seq=$((last_seq - HISTORY_COUNT + 1))
    [[ $first_seq -lt 1 ]] && first_seq=1

    # Fetch each message
    for seq in $(seq $first_seq $last_seq); do
      msg_json=$(nats stream get "$stream" "$seq" -j 2>/dev/null || echo '')
      [[ -z "$msg_json" ]] && continue

      subject=$(echo "$msg_json" | jq -r '.subject // ""')
      data=$(echo "$msg_json" | jq -r '.data // ""' | base64 -d 2>/dev/null || echo '')

      [[ -z "$data" ]] && continue

      # Add to JSON array with subject
      jq --arg subject "$subject" --argjson data "$data" \
        '. += [{"subject": $subject, "data": $data}]' \
        "$HISTORY_JSON_TMP" > "${HISTORY_JSON_TMP}.new" && mv "${HISTORY_JSON_TMP}.new" "$HISTORY_JSON_TMP"
    done
  done

  # Sort by timestamp and display each message
  jq -c 'sort_by(.data.timestamp // .data.time // .data.ts // "1970-01-01") | .[]' "$HISTORY_JSON_TMP" | while IFS= read -r entry; do
    subject=$(echo "$entry" | jq -r '.subject')
    data=$(echo "$entry" | jq -c '.data')
    format_message "$subject" "$data"
  done

  echo ""
fi

echo -e "${BOLD}${GREEN}=== Live tail on '${CYAN}$SUBJECT_PATTERN${GREEN}' (Ctrl+C to exit) ===${RESET}"

# Live tail
current_subject=""
nats sub "$SUBJECT_PATTERN" 2>/dev/null | while read -r line; do
  if [[ "$line" == *"Received on"* ]]; then
    current_subject=$(echo "$line" | sed 's/.*"\([^"]*\)".*/\1/')
    continue
  fi

  if [[ "$line" == "{"* ]]; then
    format_message "$current_subject" "$line"
  fi
done
