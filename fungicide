#!/usr/bin/env bash
# fungicide - IRC/Slack style output for NATS JetStream
# https://github.com/k4therin2/fungicide
#
# Usage: fungicide [options] [subject_pattern]
#
# Options:
#   -n, --history COUNT   Show last COUNT messages before live tail (default: 50)
#   -s, --streams LIST    Comma-separated stream names to read history from
#   -a, --all             Show all lines (don't collapse long messages)
#   -m, --military        Use 24-hour military time (default: 12-hour AM/PM)
#   -z, --timezone TZ     Timezone for display (default: local, e.g., America/New_York)
#   -w, --width WIDTH     Wrap messages at WIDTH chars (default: auto-detect, 0=no wrap)
#   -h, --help            Show this help message
#
# Examples:
#   fungicide                           # Subscribe to all subjects, 50 msg history
#   fungicide -n 20                     # Last 20 messages then live tail
#   fungicide -a                        # Show full messages (no collapsing)
#   fungicide "agent-chat.>"            # Custom subject pattern
#   fungicide -s "STREAM1,STREAM2" -n 10  # Specific streams

set -e

# Colors
RESET='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'
CYAN='\033[36m'
GREEN='\033[32m'
YELLOW='\033[33m'
MAGENTA='\033[35m'
BLUE='\033[34m'
WHITE='\033[37m'
GRAY='\033[90m'

# Channel colors (bright, for channels)
CHANNEL_COLORS=("$CYAN" "$GREEN" "$YELLOW" "$MAGENTA" "$BLUE")

# Handle colors (muted/pastel variants using 256-color codes)
# These are softer versions to distinguish from channels
HANDLE_COLORS=(
  '\033[38;5;117m'  # light blue
  '\033[38;5;151m'  # light green
  '\033[38;5;223m'  # peach
  '\033[38;5;182m'  # light purple
  '\033[38;5;174m'  # dusty rose
  '\033[38;5;152m'  # light cyan
  '\033[38;5;187m'  # light yellow
  '\033[38;5;139m'  # muted purple
)

# Random seed for channel colors (changes each run)
CHANNEL_COLOR_SEED=$RANDOM

# Temp files to track color assignments (works with bash 3)
CHANNEL_COLOR_FILE=$(mktemp)
HANDLE_COLOR_FILE=$(mktemp)

# Defaults
HISTORY_COUNT=50
SUBJECT_PATTERN=""
STREAMS=""
SHOW_ALL=false
MAX_LINES=5
MILITARY_TIME=false
TIMEZONE=""
WRAP_WIDTH=""

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -n|--history)
      HISTORY_COUNT="$2"
      shift 2
      ;;
    -s|--streams)
      STREAMS="$2"
      shift 2
      ;;
    -a|--all)
      SHOW_ALL=true
      shift
      ;;
    -m|--military)
      MILITARY_TIME=true
      shift
      ;;
    -z|--timezone)
      TIMEZONE="$2"
      shift 2
      ;;
    -w|--width)
      WRAP_WIDTH="$2"
      shift 2
      ;;
    -h|--help)
      head -26 "$0" | tail -24 | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
    *)
      SUBJECT_PATTERN="$1"
      shift
      ;;
  esac
done

# Check dependencies
if ! command -v nats &> /dev/null; then
  echo -e "${BOLD}Error:${RESET} nats CLI not found. Install with: ${CYAN}brew install nats-io/nats-tools/nats${RESET}"
  exit 1
fi

if ! command -v jq &> /dev/null; then
  echo -e "${BOLD}Error:${RESET} jq not found. Install with: ${CYAN}brew install jq${RESET}"
  exit 1
fi

if ! command -v python3 &> /dev/null; then
  echo -e "${BOLD}Error:${RESET} python3 not found."
  exit 1
fi

# Auto-detect terminal width if not specified
if [[ -z "$WRAP_WIDTH" ]]; then
  WRAP_WIDTH=$(tput cols 2>/dev/null || echo 120)
fi

# Auto-detect streams if not specified
if [[ -z "$STREAMS" ]]; then
  STREAMS=$(nats stream ls -n 2>/dev/null | tr '\n' ',' | sed 's/,$//')
fi

# Auto-detect subject pattern from first stream if not specified
if [[ -z "$SUBJECT_PATTERN" ]]; then
  first_stream=$(echo "$STREAMS" | cut -d',' -f1)
  if [[ -n "$first_stream" ]]; then
    subjects=$(nats stream info "$first_stream" -j 2>/dev/null | jq -r '.config.subjects[]? // empty' | head -1)
    if [[ -n "$subjects" ]]; then
      SUBJECT_PATTERN=$(echo "$subjects" | sed 's/\.[^.]*$/.\>/')
    fi
  fi
  if [[ -z "$SUBJECT_PATTERN" ]]; then
    SUBJECT_PATTERN=">"
  fi
fi

# Get color for channel (consistent within run, random across runs)
get_channel_color() {
  local channel="$1"

  # Check if we already assigned a color to this channel (using grep on temp file)
  local existing=$(grep "^${channel}:" "$CHANNEL_COLOR_FILE" 2>/dev/null | cut -d: -f2)
  if [[ -n "$existing" ]]; then
    echo "$existing"
    return
  fi

  # Assign a new color based on seed + channel name hash
  local hash=$CHANNEL_COLOR_SEED
  for (( i=0; i<${#channel}; i++ )); do
    hash=$((hash + $(printf '%d' "'${channel:$i:1}")))
  done
  local idx=$((hash % ${#CHANNEL_COLORS[@]}))
  local color="${CHANNEL_COLORS[$idx]}"

  # Store in temp file
  echo "${channel}:${color}" >> "$CHANNEL_COLOR_FILE"
  echo "$color"
}

# Get color for handle/agent name (consistent within run, random across runs)
get_handle_color() {
  local handle="$1"

  # Check if we already assigned a color to this handle
  local existing=$(grep "^${handle}:" "$HANDLE_COLOR_FILE" 2>/dev/null | cut -d: -f2-)
  if [[ -n "$existing" ]]; then
    echo "$existing"
    return
  fi

  # Assign a new color based on seed + handle name hash
  local hash=$CHANNEL_COLOR_SEED
  for (( i=0; i<${#handle}; i++ )); do
    hash=$((hash + $(printf '%d' "'${handle:$i:1}") * (i + 1)))
  done
  local idx=$((hash % ${#HANDLE_COLORS[@]}))
  local color="${HANDLE_COLORS[$idx]}"

  # Store in temp file
  echo "${handle}:${color}" >> "$HANDLE_COLOR_FILE"
  echo "$color"
}

# Format timestamp using python for reliable timezone conversion
format_timestamp() {
  local iso_ts="$1"
  local mil="$MILITARY_TIME"
  local tz="$TIMEZONE"

  python3 << PYEOF
import sys
from datetime import datetime

ts = "$iso_ts"
military = "$mil" == "true"
tz_override = "$tz"

try:
    # Handle various ISO formats
    if ts.endswith('Z'):
        ts = ts[:-1] + '+00:00'
    elif '.' in ts and '+' not in ts and '-' not in ts.split('T')[1]:
        ts = ts + '+00:00'

    dt = datetime.fromisoformat(ts)

    # Convert to specified or local timezone
    if tz_override:
        import zoneinfo
        target_tz = zoneinfo.ZoneInfo(tz_override)
        dt = dt.astimezone(target_tz)
    else:
        dt = dt.astimezone()

    weekday = dt.strftime('%A')
    month_day = dt.strftime('%B %d')
    year = dt.year

    if military:
        time_str = dt.strftime('%H:%M:%S')
    else:
        time_str = dt.strftime('%I:%M:%S %p')

    # Format: year|weekday|month_day|time (split so bash can bold weekday)
    print(f"{year}|{weekday}|{month_day}|{time_str}")
except Exception as e:
    print(f"{ts}|")
PYEOF
}

# Wrap text to specified width with indent
wrap_text() {
  local text="$1"
  local indent="$2"
  local width=$((WRAP_WIDTH - ${#indent}))

  if [[ "$width" -le 20 || "$WRAP_WIDTH" -eq 0 ]]; then
    echo "$text"
    return
  fi

  echo "$text" | fold -s -w "$width"
}

# Format and display a message
format_message() {
  local subject="$1"
  local json="$2"

  local channel=$(echo "$subject" | rev | cut -d'.' -f1 | rev)
  local handle=$(echo "$json" | jq -r '.handle // .user // .from // "unknown"' 2>/dev/null)
  local message=$(echo "$json" | jq -r '.message // .text // .content // .data // .' 2>/dev/null)
  local raw_timestamp=$(echo "$json" | jq -r '.timestamp // .time // .ts // ""' 2>/dev/null)

  # Format timestamp (returns "year|weekday|month_day|time")
  local ts_parts=""
  if [[ -n "$raw_timestamp" ]]; then
    ts_parts=$(format_timestamp "$raw_timestamp")
  fi
  local year_part=$(echo "$ts_parts" | cut -d'|' -f1)
  local weekday_part=$(echo "$ts_parts" | cut -d'|' -f2)
  local monthday_part=$(echo "$ts_parts" | cut -d'|' -f3)
  local time_part=$(echo "$ts_parts" | cut -d'|' -f4)

  local channel_color=$(get_channel_color "$channel")
  local handle_color=$(get_handle_color "$handle")

  # Header prefix (for calculating indent width)
  local header_plain="[$year_part] $weekday_part $monthday_part $time_part #$channel @$handle: "
  local header_len=${#header_plain}
  local indent_str=$(printf '%*s' "$header_len" '')

  if [[ -n "$message" && "$message" != "null" ]]; then
    # Count actual newlines in message
    local line_count=$(printf '%s' "$message" | wc -l | tr -d ' ')
    line_count=$((line_count + 1))

    # Always print header first
    # Format: [2025] Wednesday December 10 10:15:22 AM #channel @handle:
    # Date/time all dim, weekday slightly emphasized with color but not bold
    echo -e "${DIM}[${year_part}] ${CYAN}${weekday_part}${RESET}${DIM} ${monthday_part} ${time_part}${RESET} ${BOLD}${channel_color}#${channel}${RESET} ${BOLD}${handle_color}@${handle}${RESET}:"

    if [[ "$SHOW_ALL" == "true" || "$line_count" -le "$MAX_LINES" ]]; then
      # Show all lines with indentation (skip empty lines)
      printf '%s\n' "$message" | while IFS= read -r line; do
        [[ -n "$line" ]] && echo -e "    ${WHITE}${line}${RESET}"
      done
    else
      # More than 5 lines - show first 2, hidden count, last 3
      printf '%s\n' "$message" | head -2 | while IFS= read -r line; do
        [[ -n "$line" ]] && echo -e "    ${WHITE}${line}${RESET}"
      done
      local hidden=$((line_count - 5))
      echo -e "    ${GRAY}... ${hidden} lines hidden (use -a to expand)${RESET}"
      printf '%s\n' "$message" | tail -3 | while IFS= read -r line; do
        [[ -n "$line" ]] && echo -e "    ${WHITE}${line}${RESET}"
      done
    fi
    # Blank line after each message
    echo ""
  fi
}

# Temp file for collecting history messages
HISTORY_JSON_TMP=$(mktemp)
trap "rm -f $HISTORY_JSON_TMP $CHANNEL_COLOR_FILE $HANDLE_COLOR_FILE" EXIT

# Fetch history from streams
if [[ "$HISTORY_COUNT" -gt 0 && -n "$STREAMS" ]]; then
  echo -e "${BOLD}${MAGENTA}=== Last $HISTORY_COUNT messages ===${RESET}"

  echo '[]' > "$HISTORY_JSON_TMP"

  IFS=',' read -ra STREAM_ARRAY <<< "$STREAMS"
  for stream in "${STREAM_ARRAY[@]}"; do
    stream=$(echo "$stream" | xargs)
    [[ -z "$stream" ]] && continue

    stream_info=$(nats stream info "$stream" -j 2>/dev/null || echo '{}')
    last_seq=$(echo "$stream_info" | jq -r '.state.last_seq // 0')

    [[ "$last_seq" == "0" || "$last_seq" == "null" ]] && continue

    first_seq=$((last_seq - HISTORY_COUNT + 1))
    [[ $first_seq -lt 1 ]] && first_seq=1

    for seq in $(seq $first_seq $last_seq); do
      msg_json=$(nats stream get "$stream" "$seq" -j 2>/dev/null || echo '')
      [[ -z "$msg_json" ]] && continue

      subject=$(echo "$msg_json" | jq -r '.subject // ""')
      data=$(echo "$msg_json" | jq -r '.data // ""' | base64 -d 2>/dev/null || echo '')

      [[ -z "$data" ]] && continue

      jq --arg subject "$subject" --argjson data "$data" \
        '. += [{"subject": $subject, "data": $data}]' \
        "$HISTORY_JSON_TMP" > "${HISTORY_JSON_TMP}.new" && mv "${HISTORY_JSON_TMP}.new" "$HISTORY_JSON_TMP"
    done
  done

  jq -c 'sort_by(.data.timestamp // .data.time // .data.ts // "1970-01-01") | .[]' "$HISTORY_JSON_TMP" | while IFS= read -r entry; do
    subject=$(echo "$entry" | jq -r '.subject')
    data=$(echo "$entry" | jq -c '.data')
    format_message "$subject" "$data"
  done

  echo ""
fi

echo -e "${BOLD}${GREEN}=== Live tail on '${CYAN}$SUBJECT_PATTERN${GREEN}' (Ctrl+C to exit) ===${RESET}"

# Live tail
current_subject=""
nats sub "$SUBJECT_PATTERN" 2>/dev/null | while read -r line; do
  if [[ "$line" == *"Received on"* ]]; then
    current_subject=$(echo "$line" | sed 's/.*"\([^"]*\)".*/\1/')
    continue
  fi

  if [[ "$line" == "{"* ]]; then
    format_message "$current_subject" "$line"
  fi
done
